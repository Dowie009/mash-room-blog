---
// Footer Section: Physics Effect with Falling Blocks
---

<!-- 5. FOOTER PHYSICS (Button Rain Re-Trigger) -->
<section id="footer-physics-wrapper">
    <div id="footer-physics-canvas"></div>
    
    <div class="footer-overlay relative z-50">
        <p class="font-mono text-xs tracking-[0.5em] text-white/50 mb-8 animate-pulse">CHOOSE YOUR PATH</p>
        <div class="font-tech text-4xl font-bold text-white mb-4">
            CLICK FALLING BLOCKS
        </div>
        <div class="font-mono text-[10px] text-gray-400">
            &copy; 2025 SAPPORO MASHROOM STUDIO
        </div>
    </div>
</section>

<style>
    /* --- 5. FOOTER --- */
    #footer-physics-wrapper {
        position: relative; 
        width: 100%; 
        height: 100vh; 
        background: #000; 
        z-index: 70;
        overflow: hidden; 
        display: flex; 
        justify-content: center; 
        align-items: center;
    }
    #footer-physics-canvas { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
    }
    .footer-overlay { 
        position: relative; 
        z-index: 10; 
        pointer-events: none; 
        text-align: center; 
        mix-blend-mode: difference; 
    }
</style>

<script>
    if (typeof window !== 'undefined' && typeof Matter !== 'undefined' && typeof ScrollTrigger !== 'undefined') {
        /* ------------------------------------------------
           6. FOOTER PHYSICS
           ------------------------------------------------ */
        let footerEngine, footerRender, footerRunner;
    const footerCanvas = document.getElementById('footer-physics-canvas');

    const cleanupFooterPhysics = () => {
        if (footerRender) {
            Matter.Render.stop(footerRender);
            Matter.Runner.stop(footerRunner);
            Matter.Engine.clear(footerEngine);
            if(footerRender.canvas) footerRender.canvas.remove();
            footerRender = null;
            footerEngine = null;
            footerRunner = null;
        }
    };

    const initFooterPhysics = () => {
        if (footerRender) return;

        const Engine = Matter.Engine,
              Render = Matter.Render,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Runner = Matter.Runner,
              Events = Matter.Events;

        footerEngine = Engine.create();
        // 適度な重力：見やすく、素早く落下
        footerEngine.world.gravity.y = 1.2; // 適度な重力（速すぎず遅すぎず）
        footerEngine.world.gravity.scale = 0.001; // 通常スケール

        footerRender = Render.create({
            element: footerCanvas,
            engine: footerEngine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                background: 'transparent',
                wireframes: false
            }
        });

        const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 50, window.innerWidth, 100, { isStatic: true, render: { visible: false } });
        const leftWall = Bodies.rectangle(-50, window.innerHeight/2, 100, window.innerHeight, { isStatic: true, render: { visible: false } });
        const rightWall = Bodies.rectangle(window.innerWidth + 50, window.innerHeight/2, 100, window.innerHeight, { isStatic: true, render: { visible: false } });

        const labels = ['物語', '機材', '技術'];
        const colors = ['#ffffff', '#ff4d00', '#333333'];
        const links = ['#', '#', '#']; 

        const blocks = [];
        // ブロック数を減らして見やすく（120 → 40）
        for (let i = 0; i < 40; i++) {
            const x = Math.random() * (window.innerWidth - 150) + 75;
            const y = -Math.random() * 1500 - 100; // 順番にジャラジャラ落ちてくる
            const typeIdx = Math.floor(Math.random() * 3);

            const block = Bodies.rectangle(x, y, 140, 70, { // 少し大きめで見やすく
                chamfer: { radius: 10 },
                restitution: 0.15, // バウンドを最小限に
                density: 0.002,
                friction: 0.8, // 高摩擦で素早く安定
                frictionAir: 0.02, // 空気抵抗を増やして落下速度を抑制
                label: labels[typeIdx],
                render: {
                    fillStyle: colors[typeIdx],
                    strokeStyle: '#ffffff',
                    lineWidth: 2
                }
            });
            block.urlLink = links[typeIdx];
            blocks.push(block);
        }

        World.add(footerEngine.world, [ground, leftWall, rightWall, ...blocks]);

        const mouse = Mouse.create(footerRender.canvas);
        const mouseConstraint = MouseConstraint.create(footerEngine, {
            mouse: mouse,
            constraint: { stiffness: 0.2, render: { visible: false } }
        });
        World.add(footerEngine.world, mouseConstraint);
        footerRender.mouse = mouse;

        Events.on(mouseConstraint, 'mousedown', function(event) {
            const body = event.source.body;
            if (body && body.label) {
                console.log("Navigating to: " + body.label);
            }
        });

        Events.on(footerRender, 'afterRender', function() {
            const ctx = footerRender.context;
            ctx.font = "bold 16px 'Noto Sans JP'"; 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            blocks.forEach(block => {
                const { x, y } = block.position;
                const angle = block.angle;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.fillStyle = block.render.fillStyle === '#ffffff' ? '#000' : '#fff';
                ctx.fillText(block.label, 0, 0);
                ctx.restore();
            });
        });

        footerRunner = Runner.create();
        Runner.run(footerRunner, footerEngine);
        Render.run(footerRender);

        // ブロックが安定したら物理演算を停止（ずっと動き続けるのを防ぐ）
        let stableFrames = 0;
        const checkStability = () => {
            if (!footerEngine || !footerRunner) return;

            // 全ブロックの速度をチェック
            let allSleeping = true;
            blocks.forEach(block => {
                const speed = Math.sqrt(block.velocity.x ** 2 + block.velocity.y ** 2);
                if (speed > 0.1) { // 速度が0.1以上なら動いている
                    allSleeping = false;
                }
            });

            if (allSleeping) {
                stableFrames++;
                if (stableFrames > 120) { // 2秒安定したら停止（60fps × 2秒）
                    Matter.Runner.stop(footerRunner);
                    console.log('Footer physics stopped - blocks stable');
                    return; // 監視終了
                }
            } else {
                stableFrames = 0;
            }

            requestAnimationFrame(checkStability);
        };

        // 3秒後から安定性チェック開始（落下完了を待つ）
        setTimeout(() => {
            requestAnimationFrame(checkStability);
        }, 3000);

        window.addEventListener('resize', () => {
            if(footerRender) {
                footerRender.canvas.width = window.innerWidth;
                footerRender.canvas.height = window.innerHeight;
            }
        });
    };

    ScrollTrigger.create({
        trigger: "#footer-physics-wrapper",
        start: "top 60%", 
        onEnter: initFooterPhysics,
        onLeaveBack: cleanupFooterPhysics 
    });
    }
</script>
