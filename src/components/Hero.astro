---
// Hero Section: Intro + Gate Animation
---

<!-- 0. INTRO (クリックでスキップ可能) -->
<div id="intro-overlay" class="cursor-pointer">
    <video id="intro-video" autoplay muted playsinline>
        <source src="/images/into3.mp4" type="video/mp4">
    </video>
    <img id="intro-logo" src="/images/MASHROOM_Logo.png" alt="MASHROOM LOGO">
    <div id="skip-hint" class="absolute bottom-8 left-1/2 -translate-x-1/2 font-mono text-xs text-white/50 tracking-widest animate-pulse">
        CLICK TO SKIP
    </div>
</div>

<!-- 1. BG PHYSICS (Fixed) -->
<div id="physics-wrapper">
    <video autoplay loop muted playsinline class="absolute inset-0 w-full h-full object-cover">
        <source src="/images/sunset-bg.mp4" type="video/mp4">
    </video>
    <div class="noise-overlay"></div>
    <div id="physics-container"></div>
</div>

<!-- SCROLL METER (左上) -->
<div id="scroll-meter" class="fixed top-4 left-4 z-[101] font-mono text-xs bg-black/80 backdrop-blur px-3 py-2 rounded border border-white/20 text-white">
    <div>Scroll: <span id="scroll-value">0</span>px</div>
</div>

<!-- HEADER & GUIDE (通常時：右側縦並び / 1F時：上部横並び) -->
<header id="main-header" class="fixed top-0 w-full p-8 flex justify-between items-start z-[100] mix-blend-difference text-white pointer-events-none transition-all duration-500">
    <div class="pointer-events-auto header-logo">
        <img src="/images/MASHROOM_Logo.png" alt="MASHROOM STUDIO" class="h-12 w-auto" style="transform: scale(2.5); transform-origin: top left;">
    </div>
    <!-- 通常のフロアガイド（右側縦並び） -->
    <div id="floor-guide-vertical" class="pointer-events-auto text-left font-mono tracking-widest transition-all duration-500">
        <div class="border border-white/50 rounded-full px-5 py-2 mb-3 bg-black/20 backdrop-blur text-sm text-center">
            FLOOR GUIDE
        </div>
        <nav class="flex flex-col gap-2 opacity-90 text-xs">
            <a data-target="#hero-section" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">GATE: HERO</a>
            <div class="floor-group">
                <a data-target="#horizontal-wrapper" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">  1F: READING</a>
                <div class="floor-submenu flex flex-col gap-1 mt-1 ml-6 text-[10px] text-white/60">
                    <a data-scroll="3565" class="chapter-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">Chapter 01</a>
                    <a data-scroll="7000" class="chapter-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">Chapter 02</a>
                    <a data-scroll="9962" class="chapter-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">Chapter 03</a>
                </div>
            </div>
            <a data-target="#new-post-section" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">  2F: NEW POST</a>
            <a data-target="#footer-physics-wrapper" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">  3F: DEPART</a>
            <div class="border-t border-white/20 pt-2 mt-2 flex flex-col gap-2">
                <a href="#" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-white/50">STORY LAB →</a>
                <a href="/dtm" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer">DTM LAB →</a>
                <a href="#" class="floor-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-white/50">TECH LAB →</a>
            </div>
        </nav>
    </div>
</header>

<!-- 1F用 横並びナビゲーション（上部中央）- サイバーオレンジ -->
<nav id="floor-guide-horizontal-1f" class="fixed top-6 left-1/2 -translate-x-1/2 z-[100] text-white pointer-events-auto font-mono floor-horizontal-nav cyber-nav">
    <div class="cyber-nav-inner flex items-center gap-6 px-6 py-3">
        <a data-target="#hero-section" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">GATE</a>
        <span class="cyber-separator">|</span>
        <a data-target="#new-post-section" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">2F</a>
        <span class="cyber-separator">|</span>
        <a data-target="#footer-physics-wrapper" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">3F</a>
        <span class="cyber-separator">|</span>
        <a href="#" class="horizontal-nav-link text-white/40 hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">STORY</a>
        <a href="/dtm" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">DTM</a>
        <a href="#" class="horizontal-nav-link text-white/40 hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">TECH</a>
    </div>
</nav>

<!-- 2F用 横並びナビゲーション（右上、NEW POSTと被らない位置）- サイバーオレンジ -->
<nav id="floor-guide-horizontal-2f" class="fixed top-6 right-8 z-[100] text-white pointer-events-auto font-mono floor-horizontal-nav cyber-nav">
    <div class="cyber-nav-inner flex items-center gap-4 px-5 py-2.5">
        <a data-target="#hero-section" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">GATE</a>
        <span class="cyber-separator">|</span>
        <a data-target="#horizontal-wrapper" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">1F</a>
        <span class="cyber-separator">|</span>
        <a data-target="#footer-physics-wrapper" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">3F</a>
        <span class="cyber-separator">|</span>
        <a href="#" class="horizontal-nav-link text-white/40 hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">STORY</a>
        <a href="/dtm" class="horizontal-nav-link hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">DTM</a>
        <a href="#" class="horizontal-nav-link text-white/40 hover:text-[var(--accent-color)] transition-colors cursor-pointer text-[10px] tracking-widest">TECH</a>
    </div>
</nav>

<!-- 2. HERO GATE -->
<section class="hero-gate-container" id="hero-section">
    <div class="gate-panel gate-left">
        <div class="absolute inset-0 w-[200vw] h-full bg-black">
            <video autoplay loop muted playsinline class="w-full h-full object-cover opacity-40">
                <source src="/images/sunset-bg.mp4" type="video/mp4">
            </video>
        </div>
    </div>
    <div class="gate-panel gate-right">
        <div class="absolute inset-0 w-[200vw] h-full bg-black -left-[100%]">
            <video autoplay loop muted playsinline class="w-full h-full object-cover opacity-40">
                <source src="/images/sunset-bg.mp4" type="video/mp4">
            </video>
        </div>
    </div>
    <div class="gate-content">
        <p class="font-mono text-sm tracking-[1em] mb-8 text-white/70">SAPPORO MASHROOM STUDIO</p>
        <h2 class="font-mincho text-[10vw] leading-[0.9] font-black text-white mix-blend-overlay">
            物語と<br>技術の<br>交差点
        </h2>
        <div class="mt-12 animate-bounce">
            <span class="font-mono text-xs tracking-widest text-gray-400">SCROLL TO OPEN GATE</span>
        </div>
    </div>
</section>

<style>

    /* --- 1. INTRO & GATE --- */
    #intro-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100vh;
        z-index: 9999; background: #000; display: flex;
        justify-content: center; align-items: center; overflow: hidden;
    }
    #intro-video {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        object-fit: cover; opacity: 1;
    }
    #intro-logo {
        position: relative; z-index: 10; width: 60%; max-width: 600px; opacity: 0;
    }

    .hero-gate-container {
        position: relative; height: 100vh; width: 100%; overflow: hidden; z-index: 50; /* ゲートを確実に表示 */
    }
    .gate-panel {
        position: absolute; top: 0; width: 50%; height: 100%; background: #000; z-index: 10;
        display: flex; align-items: center; overflow: hidden;
        will-change: transform; /* ハードウェアアクセラレーション */
        transform: translateZ(0); /* GPU最適化 */
    }
    .gate-left { left: 0; justify-content: flex-end; }
    .gate-right { right: 0; justify-content: flex-start; }
    .gate-content {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        z-index: 20; text-align: center; width: 100%; pointer-events: none;
        will-change: transform, opacity; /* ハードウェアアクセラレーション */
        transform: translate(-50%, -50%) translateZ(0); /* GPU最適化 */
    }

    /* --- 2. PHYSICS LAYERS --- */
    #physics-wrapper {
        position: fixed; top: 0; left: 0; width: 100%; height: 100vh; z-index: 45; /* ゲートより下、背景より上 */
        will-change: transform; /* ハードウェアアクセラレーション */
        transform: translateZ(0); /* GPU最適化 */
    }
    #physics-container {
        width: 100%;
        height: 100%;
        position: relative;
        z-index: 55; /* ゲート（z-index: 50）より上にブロックを表示 */
        pointer-events: none; /* クリックイベントを無効化 */
        will-change: transform; /* ハードウェアアクセラレーション */
        transform: translateZ(0); /* GPU最適化 */
    }

    /* --- UTILS --- */
    .noise-overlay {
        position: absolute; inset: 0;
        background: url('https://grainy-gradients.vercel.app/noise.svg');
        opacity: 0.15; mix-blend-mode: overlay; pointer-events: none;
    }

    /* --- 横並びナビゲーション（1F/2F用） --- */
    .floor-horizontal-nav {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
    }

    /* 1F用ナビ - 中央配置 */
    #floor-guide-horizontal-1f {
        transform: translateX(-50%) translateY(-20px);
    }
    #floor-guide-horizontal-1f.visible {
        opacity: 1 !important;
        visibility: visible !important;
        pointer-events: auto !important;
        transform: translateX(-50%) translateY(0);
    }

    /* 2F用ナビ - 右上配置 */
    #floor-guide-horizontal-2f {
        transform: translateY(-20px);
    }
    #floor-guide-horizontal-2f.visible {
        opacity: 1 !important;
        visibility: visible !important;
        pointer-events: auto !important;
        transform: translateY(0);
    }

    .horizontal-nav-link {
        font-weight: 600;
        letter-spacing: 0.15em;
        transition: all 0.3s ease;
    }
    .horizontal-nav-link:hover {
        transform: translateY(-1px);
    }

    /* --- サイバーオレンジ ナビゲーション（ブロック風角丸四角） --- */
    .cyber-nav {
        /* mix-blend-modeを削除してオレンジを見せる */
    }

    .cyber-nav-inner {
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(12px);
        border-radius: 10px; /* ブロック風の角丸 */
        border: 2px solid var(--accent-color, #ff4d00);
        box-shadow:
            0 0 15px rgba(255, 77, 0, 0.2),
            0 4px 20px rgba(0, 0, 0, 0.5);
        position: relative;
    }

    /* セパレーター */
    .cyber-separator {
        color: var(--accent-color, #ff4d00);
        opacity: 0.5;
        font-size: 12px;
    }

    /* アクティブリンクのオレンジ強調 */
    .cyber-nav .horizontal-nav-link.active {
        color: var(--accent-color, #ff4d00);
    }

    /* 縦フロアガイドを非表示（1F/2F時） */
    #floor-guide-vertical.hidden-on-floor {
        opacity: 0 !important;
        visibility: hidden !important;
        transform: translateX(20px);
    }
</style>

<script>
    if (typeof window !== 'undefined') {
        // リロード時にページトップに戻る
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);

        // Initialize immediately when scripts are available
        const initAll = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            if (typeof gsap !== 'undefined' && typeof ScrollTrigger !== 'undefined' && typeof ScrollToPlugin !== 'undefined') {
                gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

                /* ------------------------------------------------
                   0. SMOOTH SCROLL (LENIS)
                   ------------------------------------------------ */
                if (typeof Lenis !== 'undefined') {
                    const lenis = new Lenis({
                        // Apple/Stripe風の気持ちいいスクロール設定
                        duration: 1.2, // 滑らかだが遅すぎない（Apple風）
                        easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), // exponential decay
                        smooth: true,
                        lerp: 0.1, // 自然な追従感（0.08-0.12がApple風）
                        smoothTouch: true,
                        touchMultiplier: 1.8, // タッチ感度
                        wheelMultiplier: 1.0, // ホイール感度（標準）
                        infinite: false,
                    });

                    // Lenisをグローバルに公開（3Fメニューなど他のコンポーネントで使用）
                    window.lenis = lenis;
                    
                    // スクロールメーターを更新
                    const updateScrollMeter = () => {
                        const scrollValue = document.getElementById('scroll-value');
                        if (scrollValue) {
                            scrollValue.textContent = Math.round(window.scrollY || window.pageYOffset || 0);
                        }
                    };
                    
                    // スクロール時のブロック揺れ用の変数
                    let lastScrollY = 0;
                    
                    // スクロール位置に応じて地面の位置を調整
                    const updateGroundPosition = () => {
                        if (!window.physicsGround || !window.physicsBlocks) return;
                        if (typeof Matter === 'undefined' || !Matter.Body) return;
                        
                        const scrollY = window.scrollY || window.pageYOffset || 0;
                        const heroSection = document.querySelector('.hero-gate-container');
                        const horizontalWrapper = document.querySelector('.horizontal-wrapper');
                        
                        if (!heroSection || !horizontalWrapper) return;
                        
                        const heroBottom = heroSection.offsetTop + heroSection.offsetHeight;
                        const horizontalTop = horizontalWrapper.offsetTop;
                        
                        // 保存されたオフセットを使用（-700など、ユーザーが設定した値）
                        const groundYOffset = window.physicsGroundYOffset !== undefined ? window.physicsGroundYOffset : 100;
                        
                        // 地面の位置は常に画面の一番下を基準に、groundYOffsetを適用（固定位置）
                        // スクロール位置に関係なく、画面の一番下からの距離で地面を配置
                        const fixedGroundY = window.innerHeight + groundYOffset;
                        
                        Matter.Body.setPosition(window.physicsGround, {
                            x: window.innerWidth / 2,
                            y: fixedGroundY
                        });
                        window.physicsGroundY = fixedGroundY;
                    };
                    
                    const applyScrollShake = () => {
                        if (!window.physicsBlocks || window.physicsBlocks.length === 0) return;
                        if (typeof Matter === 'undefined' || !Matter.Body) return;
                        
                        const currentScrollY = window.scrollY || window.pageYOffset || 0;
                        const scrollDelta = Math.abs(currentScrollY - lastScrollY);
                        
                        if (scrollDelta > 0.5) {
                            // スクロール時にブロックに小さな力を加えて揺らす
                            window.physicsBlocks.forEach((block) => {
                                if (!block || !block.position) return;
                                
                                const blockY = block.position.y;
                                // ブロックが地面付近にいる場合のみ揺らす
                                if (blockY >= (window.physicsGroundY || 0) - 150) {
                                    const shakeForce = scrollDelta * 0.008; // スクロール量に応じた力
                                    const randomX = (Math.random() - 0.5) * shakeForce;
                                    const randomY = (Math.random() - 0.5) * shakeForce * 0.3; // 縦方向は弱め
                                    
                                    Matter.Body.applyForce(block, block.position, {
                                        x: randomX,
                                        y: randomY
                                    });
                                }
                            });
                        }
                        
                        lastScrollY = currentScrollY;
                    };
                    
                    // LenisとScrollTriggerを連携させる（チカつき防止）
                    lenis.on('scroll', ScrollTrigger.update);

                    // GSAPのtickerを使用してスムーズに同期
                    gsap.ticker.add((time) => {
                        lenis.raf(time * 1000); // GSAPのtickerはsecond単位なのでms変換
                    });

                    // GSAPのtickerのラグを無効化（よりスムーズに）
                    gsap.ticker.lagSmoothing(0);

                    function raf(time) {
                        updateScrollMeter();
                        updateGroundPosition(); // スクロール位置に応じて地面の位置を更新
                        applyScrollShake(); // スクロール時のブロック揺れ
                        requestAnimationFrame(raf);
                    }
                    requestAnimationFrame(raf);

                    /* ------------------------------------------------
                       1. FLOOR GUIDE (Fixed Logic - スクロール位置ベース)
                       ------------------------------------------------ */
                    const navLinks = document.querySelectorAll('.floor-link');
                    const chapterLinks = document.querySelectorAll('.chapter-link');
                    const gateLink = document.querySelector('[data-target="#hero-section"]');
                    const floor1Link = document.querySelector('[data-target="#horizontal-wrapper"]');
                    const floor2Link = document.querySelector('[data-target="#new-post-section"]');
                    const floor3Link = document.querySelector('[data-target="#footer-physics-wrapper"]');
                    
                    // 横並びナビゲーションの要素を取得
                    const floorGuideVertical = document.getElementById('floor-guide-vertical');
                    const floorGuideHorizontal1F = document.getElementById('floor-guide-horizontal-1f');
                    const floorGuideHorizontal2F = document.getElementById('floor-guide-horizontal-2f');
                    const horizontalNavLinks = document.querySelectorAll('.horizontal-nav-link');

                    // スクロール値ベースのメニュー表示タイミング
                    // 1F: 2274px開始 → 2471px完成
                    // 2F: 6816px開始 → 7179px完成
                    const MENU_1F_START = 2274;
                    const MENU_1F_END = 2471;
                    const MENU_2F_START = 6816;
                    const MENU_2F_END = 7179;

                    // スクロール位置に応じてアクティブなフロアを更新
                    const updateActiveFloor = () => {
                        const scrollY = window.scrollY || window.pageYOffset || 0;
                        const viewportHeight = window.innerHeight;

                        // 各セクションのDOM要素を取得
                        const heroSection = document.getElementById('hero-section');
                        const horizontalWrapper = document.getElementById('horizontal-wrapper');
                        const newPostSection = document.getElementById('new-post-section');
                        const footerSection = document.getElementById('footer-physics-wrapper');

                        // 各セクションの位置を動的に取得（画面中央を基準）
                        const getTop = (el) => el ? el.getBoundingClientRect().top + scrollY : Infinity;

                        const heroTop = getTop(heroSection);
                        const readingTop = getTop(horizontalWrapper);
                        const newPostTop = getTop(newPostSection);
                        const footerTop = getTop(footerSection);

                        // すべてのリンクからactiveクラスを削除
                        navLinks.forEach(l => l.classList.remove('active'));
                        chapterLinks.forEach(l => l.classList.remove('active'));

                        // 現在のスクロール位置（画面中央を基準）
                        const currentPos = scrollY + viewportHeight * 0.4;

                        // フロア判定フラグ
                        let currentFloor = 'gate'; // gate, 1f, 2f, 3f

                        // スクロール位置に応じてアクティブなフロアを設定
                        if (currentPos >= footerTop) {
                            // 3F: DEPART
                            currentFloor = '3f';
                            if (floor3Link) floor3Link.classList.add('active');
                        } else if (currentPos >= newPostTop) {
                            // 2F: NEW POST
                            currentFloor = '2f';
                            if (floor2Link) floor2Link.classList.add('active');
                        } else if (currentPos >= readingTop) {
                            // 1F: READING
                            currentFloor = '1f';
                            if (floor1Link) floor1Link.classList.add('active');

                            // Chapter判定（horizontal-scroll内のパネル位置）
                            const scrollProgress = (scrollY - readingTop) / (newPostTop - readingTop);

                            if (scrollProgress >= 0.66) {
                                // Chapter03
                                const chapter3 = document.querySelector('.chapter-link[data-scroll="9962"]');
                                if (chapter3) chapter3.classList.add('active');
                            } else if (scrollProgress >= 0.33) {
                                // Chapter02
                                const chapter2 = document.querySelector('.chapter-link[data-scroll="7000"]');
                                if (chapter2) chapter2.classList.add('active');
                            } else if (scrollProgress >= 0) {
                                // Chapter01
                                const chapter1 = document.querySelector('.chapter-link[data-scroll="3565"]');
                                if (chapter1) chapter1.classList.add('active');
                            }
                        } else {
                            // GATE: HERO
                            currentFloor = 'gate';
                            if (gateLink) gateLink.classList.add('active');
                        }

                        // スクロール値ベースのメニュー表示制御
                        // フロアに応じてメニューを切り替え
                        if (currentFloor === '1f') {
                            // 1F: 横並びナビ（中央）を表示
                            floorGuideHorizontal1F?.classList.add('visible');
                            floorGuideHorizontal2F?.classList.remove('visible');
                            floorGuideVertical?.classList.add('hidden-on-floor');
                        }
                        else if (currentFloor === '2f') {
                            // 2F: 横並びナビ（右上）を表示
                            floorGuideHorizontal1F?.classList.remove('visible');
                            floorGuideHorizontal2F?.classList.add('visible');
                            floorGuideVertical?.classList.add('hidden-on-floor');
                        }
                        else if (currentFloor === '3f') {
                            // 3F: 全メニュー非表示（Footer.astroのグリッチメニューが担当）
                            floorGuideHorizontal1F?.classList.remove('visible');
                            floorGuideHorizontal2F?.classList.remove('visible');
                            floorGuideVertical?.classList.add('hidden-on-floor');
                        }
                        else {
                            // ゲート: 通常の縦ナビを表示
                            floorGuideHorizontal1F?.classList.remove('visible');
                            floorGuideHorizontal2F?.classList.remove('visible');
                            floorGuideVertical?.classList.remove('hidden-on-floor');
                        }
                    };
                    
                    // スクロール時にアクティブなフロアを更新
                    if (typeof Lenis !== 'undefined') {
                        // Lenisのraf内で実行
                        const originalRaf = window.requestAnimationFrame;
                        let rafId;
                        const floorUpdateRaf = () => {
                            updateActiveFloor();
                            rafId = originalRaf(floorUpdateRaf);
                        };
                        rafId = originalRaf(floorUpdateRaf);
                    } else {
                        window.addEventListener('scroll', updateActiveFloor, { passive: true });
                    }
                    
                    // 初期状態を設定
                    updateActiveFloor();
                    
                    // Click scroll (フロアリンク)
                    navLinks.forEach(link => {
                        const targetId = link.getAttribute('data-target');
                        if(targetId) {
                            link.addEventListener('click', (e) => {
                                const target = document.querySelector(targetId);
                                if (target && lenis) {
                                    lenis.scrollTo(target);
                                }
                            });
                        }
                    });
                    
                    // Click scroll (Chapterリンク)
                    chapterLinks.forEach(link => {
                        const scrollValue = link.getAttribute('data-scroll');
                        if(scrollValue) {
                            link.addEventListener('click', (e) => {
                                if (lenis) {
                                    lenis.scrollTo(parseInt(scrollValue), { duration: 1.5 });
                                }
                            });
                        }
                    });

                    // Click scroll (横並びナビリンク)
                    horizontalNavLinks.forEach(link => {
                        const targetId = link.getAttribute('data-target');
                        if(targetId) {
                            link.addEventListener('click', (e) => {
                                const target = document.querySelector(targetId);
                                if (target && lenis) {
                                    lenis.scrollTo(target, { duration: 1.5 });
                                }
                            });
                        }
                    });
                }

                /* ------------------------------------------------
                   2. INTRO & GATE ANIMATION
                   ------------------------------------------------ */
                let introTimeline = null;
                let introSkipped = false;

                const skipIntro = () => {
                    if (introSkipped) return;
                    introSkipped = true;

                    // アニメーションを即座に完了させる
                    if (introTimeline) {
                        introTimeline.kill();
                    }

                    // イントロを即座に非表示
                    gsap.to("#intro-overlay", {
                        opacity: 0,
                        duration: 0.3,
                        pointerEvents: 'none',
                        onComplete: () => {
                            initPhysics();
                        }
                    });
                };

                const startIntro = () => {
                    introTimeline = gsap.timeline({
                        onComplete: () => {
                            if (!introSkipped) {
                                initPhysics();
                            }
                        }
                    });
                    introTimeline.to("#intro-logo", { opacity: 1, scale: 1, duration: 1, ease: "power2.out", delay: 0.5 })
                      .to("#intro-logo", { scale: 1.05, duration: 1.5 })
                      .to("#intro-logo", { opacity: 0, scale: 1.2, duration: 0.5 }, "-=0.2")
                      .to("#intro-overlay", { opacity: 0, duration: 1, pointerEvents: 'none' });
                };

                // イントロをクリックでスキップ
                const introOverlay = document.getElementById('intro-overlay');
                if (introOverlay) {
                    introOverlay.addEventListener('click', skipIntro);
                }

                window.addEventListener('load', startIntro);

                const gateTl = gsap.timeline({
                    scrollTrigger: {
                        trigger: ".hero-gate-container",
                        start: "top top",
                        end: "+=100%",
                        scrub: 1.0, // Apple風：滑らかな追従
                        pin: true,
                        anticipatePin: 1,
                        invalidateOnRefresh: true,
                        onStart: () => {
                            // ゲートが開き始めたときに物理演算を開始
                            initPhysics();
                        }
                    }
                });
                gateTl.to(".gate-left", { xPercent: -100, ease: "none" }, "open")
                      .to(".gate-right", { xPercent: 100, ease: "none" }, "open")
                      .to(".gate-content", { y: -200, opacity: 0, ease: "none" }, "open");

                /* ------------------------------------------------
                   3. BACKGROUND PHYSICS (Floor 1)
                   ------------------------------------------------ */
                const initPhysics = () => {
                    const container = document.getElementById('physics-container');
                    // 元のgemini-html.htmlと同じ：コンテナに既に子要素がある場合は再初期化しない
                    if(container.childNodes.length > 0) return;

                    const Engine = Matter.Engine,
                          Render = Matter.Render,
                          World = Matter.World,
                          Bodies = Matter.Bodies,
                          Runner = Matter.Runner;

                    const engine = Engine.create();
                    // ジャラジャラ高速落下バージョン：重力を強くして、ブロックがジャラジャラっと素早く落ちる
                    engine.world.gravity.y = 2.5; // 2.5倍の重力で高速落下
                    engine.world.gravity.scale = 0.002; // スケールも2倍で加速
                    window.physicsEngine = engine; // グローバルに保存
                    
                    const render = Render.create({
                        element: container,
                        engine: engine,
                        options: {
                            width: window.innerWidth,
                            height: window.innerHeight,
                            background: 'transparent',
                            wireframes: false
                        }
                    });

                    // 地面の位置を設定可能にする（画面の一番下を指定）
                    // ここで地面のY位置を指定できます（画面の高さに対する相対位置）
                    // 例：window.innerHeight + 100 = 画面の下から100px下
                    // 例：window.innerHeight - 50 = 画面の下から50px上
                    const groundYOffset = 80 // この値を変更して地面の位置を調整（画面の下からの距離）
                    const groundY = window.innerHeight + groundYOffset;
                    
                    // 最初の地面（Heroセクションの地面）
                    const ground = Bodies.rectangle(window.innerWidth/2, groundY, window.innerWidth, 200, { 
                        isStatic: true, 
                        render: { visible: false },
                        friction: 0.8, // 摩擦を追加してブロックが滑らないように
                        frictionAir: 0.01 // 空気抵抗を追加
                    });
                    const leftWall = Bodies.rectangle(-50, window.innerHeight/2, 100, window.innerHeight*2, { isStatic: true, render: { visible: false } });
                    const rightWall = Bodies.rectangle(window.innerWidth + 50, window.innerHeight/2, 100, window.innerHeight*2, { isStatic: true, render: { visible: false } });

                    const blocks = Array.from({ length: 30 }).map((_, i) => {
                        const x = Math.random() * (window.innerWidth - 200) + 100;
                        const y = -Math.random() * 800 - 100; // 落下開始位置を近くして早く画面に登場
                        return Bodies.rectangle(x, y, 160 + Math.random()*40, 100 + Math.random()*20, {
                            chamfer: { radius: 12 },
                            restitution: 0.3, // バウンドを抑えて素早く安定
                            density: 0.003, // より重く（落下加速）
                            friction: 0.5, // 摩擦強めで素早く止まる
                            frictionAir: 0.005, // 空気抵抗を減らして高速落下
                            render: {
                                fillStyle: 'transparent',
                                strokeStyle: i % 2 === 0 ? '#ff4d00' : '#ffffff',
                                lineWidth: 3 // 少し細めの線
                            }
                        });
                    });

                    // 「重力と遊ぶ」カード用の物理ボディを作成
                    const gravityCard = Bodies.rectangle(
                        window.innerWidth / 2,  // 画面中央
                        window.innerHeight + 500, // 画面外下から開始
                        600,  // カードの幅
                        400,  // カードの高さ
                        {
                            isStatic: true,
                            render: {
                                visible: false  // デバッグ時はtrueにすると物理ボディの位置が見える
                            }
                        }
                    );

                    World.add(engine.world, [ground, leftWall, rightWall, ...blocks, gravityCard]);

                    // グローバル変数に保存
                    if (typeof window !== 'undefined') {
                        window.physicsBlocks = blocks;
                        window.physicsGround = ground;
                        window.physicsGroundY = groundY;
                        window.physicsGroundYOffset = groundYOffset; // 地面のオフセットを保存（重要！）
                        window.physicsGravityCard = gravityCard; // カードのボディを保存
                        console.log('Ground position set:', {
                            groundY: groundY,
                            groundYOffset: groundYOffset,
                            windowHeight: window.innerHeight,
                            calculated: window.innerHeight + groundYOffset
                        });
                    }

                    const runner = Runner.create();
                    Runner.run(runner, engine);
                    Render.run(render);

                    // カードの位置を追跡してMatter.jsボディを更新
                    const updateCardPosition = () => {
                        const cardElement = document.querySelector('.skeleton-text-box');
                        if (cardElement && window.physicsGravityCard) {
                            const rect = cardElement.getBoundingClientRect();
                            // カードの画面上の位置（screen座標）
                            const screenY = rect.top + rect.height / 2;
                            const screenX = rect.left + rect.width / 2;

                            // Matter.jsのボディの位置を更新
                            Matter.Body.setPosition(window.physicsGravityCard, {
                                x: screenX,
                                y: screenY
                            });
                        }
                    };

                    // スクロールイベントでカードの位置を更新
                    if (typeof Lenis !== 'undefined') {
                        // Lenisを使用している場合はraf内で実行
                        const originalRaf = window.requestAnimationFrame;
                        let cardRafId;
                        const cardUpdateRaf = () => {
                            updateCardPosition();
                            cardRafId = originalRaf(cardUpdateRaf);
                        };
                        cardRafId = originalRaf(cardUpdateRaf);
                    } else {
                        // Lenisがない場合は通常のscrollイベント
                        window.addEventListener('scroll', updateCardPosition, { passive: true });
                    }
                };
            }
        };

        // Initialize when DOM is ready (not waiting for all resources)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAll);
        } else {
            // DOM is already ready, initialize immediately
            initAll();
        }
    }
</script>
